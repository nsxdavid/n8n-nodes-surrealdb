import type {
	IExecuteFunctions,
	IDataObject,
	INodeExecutionData,
	INodeType,
	INodeTypeDescription,
	JsonObject,
	IHttpRequestOptions,
} from 'n8n-workflow';

// Set to true to enable debug logging, false to disable
const DEBUG = false;

import {
	connectSurrealClient,
	prepareSurrealQuery,
	validateAndResolveSurrealCredentials,
	validateJSON,
	validateRequiredField,
} from './GenericFunctions';
import { nodeProperties } from './SurrealDbProperties';
import { createRecordId, formatSingleResult, formatArrayResult, parseAndValidateRecordId } from './utilities';

export class SurrealDb implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'SurrealDB',
		name: 'surrealDb',
		icon: 'file:surrealdb.svg',
		group: ['input'],
		version: 1,
		description: 'Interaction with a SurrealDB database',
		subtitle: '={{$parameter["action"]}}',
		defaults: {
			name: 'SurrealDB',
		},
		inputs: ['main'] as any,
		outputs: ['main'] as any,
		usableAsTool: true,
		credentials: [
			{
				name: 'surrealDbApi',
				required: true,
			},
		],
		properties: nodeProperties,
	};

	// No custom credential test method needed as we're using the standard n8n credential test
	methods = {};

	async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
		const credentials = await this.getCredentials('surrealDbApi');

		// Get options for the current operation to retrieve potential namespace/database overrides
		const options = this.getNodeParameter('options', 0, {}) as IDataObject;
		const nodeNamespace = (options.namespace as string)?.trim() || '';
		const nodeDatabase = (options.database as string)?.trim() || '';

		// Resolve credentials, passing in overrides
		const resolvedCredentials = validateAndResolveSurrealCredentials(
			this,
			credentials,
			nodeNamespace, // Pass the renamed variable
			nodeDatabase, // Pass the renamed variable
		);

		if (DEBUG) {
			console.log('DEBUG - Resolved Credentials:', JSON.stringify(resolvedCredentials));
		}

		const client = await connectSurrealClient(resolvedCredentials);

		let returnData: INodeExecutionData[] = [];

		const items = this.getInputData();
		const resource = this.getNodeParameter('resource', 0) as string;
		const operation = this.getNodeParameter('operation', 0) as string;
		
		const itemsLength = items.length;

		try {
			// ----------------------------------------
			// Resource: Record
			// ----------------------------------------
			if (resource === 'record') {
				
				// Operation: Create Record
				if (operation === 'createRecord') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							// Get parameters
							let table = this.getNodeParameter('table', i) as string;
							validateRequiredField(this, table, 'Table', i);

							// Ensure table is a string
							table = String(table || '');
							
							// If table contains a colon, use only the part before the colon
							if (table.includes(':')) {
								table = table.split(':')[0];
							}
							
							const dataInput = this.getNodeParameter('data', i); // Get potential object or string
							// Validate required field based on raw input
							if (dataInput === undefined || dataInput === null || dataInput === '') {
								throw new Error('Data is required');
							}
							
							// Process data based on type
							let data: any;
							if (typeof dataInput === 'string') {
								if (DEBUG) console.log(`DEBUG (createRecord) - Processing data parameter as string.`);
								data = validateJSON(this, dataInput, i);
							} else if (typeof dataInput === 'object' && dataInput !== null) { // Check if it's a non-null object
								if (DEBUG) console.log(`DEBUG (createRecord) - Processing data parameter as object.`);
								data = dataInput;
							} else {
								throw new Error(`Data must be a JSON string or a JSON object, received type: ${typeof dataInput}`);
							}
							if (DEBUG) console.log(`DEBUG (createRecord) - Processed data (type: ${typeof data}):`, JSON.stringify(data));
							
							// Execute the create operation
							const result = await client.create(table, data);
							
							// Format the result
							const formattedResult = formatSingleResult(result);
							returnData.push({
								...formattedResult,
								pairedItem: { item: i },
							});
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
				
				// Operation: Get Record
				else if (operation === 'getRecord') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							// Get parameters
							let table = this.getNodeParameter('table', i) as string;
							const idInput = this.getNodeParameter('id', i) as string;

							// Ensure table is a string
							table = String(table || '');
							
							// If table contains a colon, use only the part before the colon
							if (table.includes(':')) {
								table = table.split(':')[0];
							}

							// Ensure idInput is a string
							const idInputStr = String(idInput || '');
							
							// If no table is specified but idInput has a table prefix, use the extracted table
							if (!table && idInputStr.includes(':')) {
								table = idInputStr.split(':')[0];
							}
							
							// Only validate table as required if it couldn't be extracted from the Record ID
							if (!table) {
								throw new Error('Either Table field must be provided or Record ID must include a table prefix (e.g., "table:id")');
							}
							validateRequiredField(this, idInput, 'Record ID', i);

							// Parse and validate the record ID string
							const validatedId = parseAndValidateRecordId(idInput, table, this.getNode(), i);
							
							// Create the record ID
							const recordId = createRecordId(table, validatedId);
							
							// Execute the select operation
							const result = await client.select(recordId);
							
							// Check if the record was found (result is not null/undefined/empty object)
							// SurrealDB's client.select returns the record object if found, or null/undefined if not found.
							// An empty object check is included for robustness, though less likely.
							if (result !== null && result !== undefined && (typeof result !== 'object' || Object.keys(result).length > 0)) {
								// Format the result only if found
								const formattedResult = formatSingleResult(result);
								returnData.push({
									...formattedResult,
									pairedItem: { item: i },
								});
							}
							// If not found, do nothing, resulting in zero items for this input item
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
				
				// Operation: Update Record
				else if (operation === 'updateRecord') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							// Get parameters
							let table = this.getNodeParameter('table', i) as string;
							const idInput = this.getNodeParameter('id', i) as string;

							// Ensure table is a string
							table = String(table || '');
							
							// If table contains a colon, use only the part before the colon
							if (table.includes(':')) {
								table = table.split(':')[0];
							}

							// Ensure idInput is a string
							const idInputStr = String(idInput || '');
							
							// If no table is specified but idInput has a table prefix, use the extracted table
							if (!table && idInputStr.includes(':')) {
								table = idInputStr.split(':')[0];
							}

							// Only validate table as required if it couldn't be extracted from the Record ID
							if (!table) {
								throw new Error('Either Table field must be provided or Record ID must include a table prefix (e.g., "table:id")');
							}
							validateRequiredField(this, idInput, 'Record ID', i);

							// Parse and validate the record ID string
							const validatedId = parseAndValidateRecordId(idInput, table, this.getNode(), i);
							
							const dataInput = this.getNodeParameter('data', i); // Get potential object or string
							// Validate required field based on raw input
							if (dataInput === undefined || dataInput === null || dataInput === '') {
								throw new Error('Data is required');
							}
							
							// Process data based on type
							let data: any;
							if (typeof dataInput === 'string') {
								if (DEBUG) console.log(`DEBUG (updateRecord) - Processing data parameter as string.`);
								data = validateJSON(this, dataInput, i);
							} else if (typeof dataInput === 'object' && dataInput !== null) { // Check if it's a non-null object
								if (DEBUG) console.log(`DEBUG (updateRecord) - Processing data parameter as object.`);
								data = dataInput;
							} else {
								throw new Error(`Data must be a JSON string or a JSON object, received type: ${typeof dataInput}`);
							}
							if (DEBUG) console.log(`DEBUG (updateRecord) - Processed data (type: ${typeof data}):`, JSON.stringify(data));
							
							// Create the record ID
							const recordId = createRecordId(table, validatedId);
							
							if (DEBUG) {
								console.log('DEBUG - Update Record - Record ID:', recordId);
								console.log('DEBUG - Update Record - Data:', JSON.stringify(data));
							}

							// Execute the update operation
							const result = await client.update(recordId, data);
							
							// Format the result
							const formattedResult = formatSingleResult(result);
							returnData.push({
								...formattedResult,
								pairedItem: { item: i },
							});
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
				
				// Operation: Merge Record
				else if (operation === 'mergeRecord') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							// Get parameters
							let table = this.getNodeParameter('table', i) as string;
							const idInput = this.getNodeParameter('id', i) as string;

							// Ensure table is a string
							table = String(table || '');
							
							// If table contains a colon, use only the part before the colon
							if (table.includes(':')) {
								table = table.split(':')[0];
							}

							// Ensure idInput is a string
							const idInputStr = String(idInput || '');
							
							// If no table is specified but idInput has a table prefix, use the extracted table
							if (!table && idInputStr.includes(':')) {
								table = idInputStr.split(':')[0];
							}

							// Only validate table as required if it couldn't be extracted from the Record ID
							if (!table) {
								throw new Error('Either Table field must be provided or Record ID must include a table prefix (e.g., "table:id")');
							}
							validateRequiredField(this, idInput, 'Record ID', i);

							// Parse and validate the record ID string
							const validatedId = parseAndValidateRecordId(idInput, table, this.getNode(), i);
							
							const dataInput = this.getNodeParameter('data', i); // Get potential object or string
							// Validate required field based on raw input
							if (dataInput === undefined || dataInput === null || dataInput === '') {
								throw new Error('Data is required');
							}
							
							// Process data based on type
							let data: any;
							if (typeof dataInput === 'string') {
								if (DEBUG) console.log(`DEBUG (mergeRecord) - Processing data parameter as string.`);
								data = validateJSON(this, dataInput, i);
							} else if (typeof dataInput === 'object' && dataInput !== null) { // Check if it's a non-null object
								if (DEBUG) console.log(`DEBUG (mergeRecord) - Processing data parameter as object.`);
								data = dataInput;
							} else {
								throw new Error(`Data must be a JSON string or a JSON object, received type: ${typeof dataInput}`);
							}
							if (DEBUG) console.log(`DEBUG (mergeRecord) - Processed data (type: ${typeof data}):`, JSON.stringify(data));
							
							// Create the record ID
							const recordId = createRecordId(table, validatedId);
							
							// Execute the merge operation
							const result = await client.merge(recordId, data);
							
							// Format the result
							const formattedResult = formatSingleResult(result);
							returnData.push({
								...formattedResult,
								pairedItem: { item: i },
							});
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
				
				// Operation: Delete Record
				else if (operation === 'deleteRecord') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							// Get parameters
							let table = this.getNodeParameter('table', i) as string;
							const idInput = this.getNodeParameter('id', i) as string;

							// Ensure table is a string
							table = String(table || '');
							
							// If table contains a colon, use only the part before the colon
							if (table.includes(':')) {
								table = table.split(':')[0];
							}

							// Ensure idInput is a string
							const idInputStr = String(idInput || '');
							
							// If no table is specified but idInput has a table prefix, use the extracted table
							if (!table && idInputStr.includes(':')) {
								table = idInputStr.split(':')[0];
							}

							// Only validate table as required if it couldn't be extracted from the Record ID
							if (!table) {
								throw new Error('Either Table field must be provided or Record ID must include a table prefix (e.g., "table:id")');
							}
							validateRequiredField(this, idInput, 'Record ID', i);

							// Parse and validate the record ID string
							const validatedId = parseAndValidateRecordId(idInput, table, this.getNode(), i);
							
							// Create the record ID
							const recordId = createRecordId(table, validatedId);
							
							// Execute the delete operation
							const result = await client.delete(recordId);
							
							// Format the result
							const formattedResult = formatSingleResult(result);
							returnData.push({
								...formattedResult,
								pairedItem: { item: i },
							});
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
				
				// Operation: Upsert Record
				else if (operation === 'upsertRecord') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							// Get parameters
							let table = this.getNodeParameter('table', i) as string;
							const idInput = this.getNodeParameter('id', i) as string;

							// Ensure table is a string
							table = String(table || '');
							
							// If table contains a colon, use only the part before the colon
							if (table.includes(':')) {
								table = table.split(':')[0];
							}

							// Ensure idInput is a string
							const idInputStr = String(idInput || '');
							
							// If no table is specified but idInput has a table prefix, use the extracted table
							if (!table && idInputStr.includes(':')) {
								table = idInputStr.split(':')[0];
							}

							// Only validate table as required if it couldn't be extracted from the Record ID
							if (!table) {
								throw new Error('Either Table field must be provided or Record ID must include a table prefix (e.g., "table:id")');
							}
							validateRequiredField(this, idInput, 'Record ID', i);

							// Parse and validate the record ID string
							const validatedId = parseAndValidateRecordId(idInput, table, this.getNode(), i);
							
							const dataInput = this.getNodeParameter('data', i); // Get potential object or string
							// Validate required field based on raw input
							if (dataInput === undefined || dataInput === null || dataInput === '') {
								throw new Error('Data is required');
							}
							
							// Process data based on type
							let data: any;
							if (typeof dataInput === 'string') {
								if (DEBUG) console.log(`DEBUG (upsertRecord) - Processing data parameter as string.`);
								data = validateJSON(this, dataInput, i);
							} else if (typeof dataInput === 'object' && dataInput !== null) { // Check if it's a non-null object
								if (DEBUG) console.log(`DEBUG (upsertRecord) - Processing data parameter as object.`);
								data = dataInput;
							} else {
								throw new Error(`Data must be a JSON string or a JSON object, received type: ${typeof dataInput}`);
							}
							if (DEBUG) console.log(`DEBUG (upsertRecord) - Processed data (type: ${typeof data}):`, JSON.stringify(data));
							
							// Create the record ID
							const recordId = createRecordId(table, validatedId);
							
							if (DEBUG) {
								console.log('DEBUG - Upsert Record - Before client.upsert - Record ID:', recordId);
								console.log('DEBUG - Upsert Record - Before client.upsert - Data:', JSON.stringify(data));
								console.log('DEBUG - Upsert Record - Before client.upsert - Client state:', client);
							}
							
							let formattedResult;
							try {
								// For upsert, we use the upsert method which will create the record if it doesn't exist
								// According to the SurrealDB documentation, this is the correct method for upserting records
								const result = await client.upsert(recordId, data);
								
								if (DEBUG) {
									console.log('DEBUG - Upsert Record - After client.upsert - Result:', JSON.stringify(result));
								}
								
								// Format the result
								formattedResult = formatSingleResult(result);
							} catch (upsertError) {
								if (DEBUG) {
									console.error('DEBUG - Upsert Record - Error during client.upsert:', upsertError);
									console.error('DEBUG - Upsert Record - Error stack:', (upsertError as Error).stack);
								}
								throw upsertError;
							}
							
							returnData.push({
								...formattedResult,
								pairedItem: { item: i },
							});
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
			}
			
			// ----------------------------------------
			// Resource: Table
			// ----------------------------------------
			else if (resource === 'table') {
				
				// Operation: Get All Records
				if (operation === 'getAllRecords') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							// Get parameters
							let table = this.getNodeParameter('table', i) as string;
							validateRequiredField(this, table, 'Table', i);

							// Ensure table is a string
							table = String(table || '');
							
							// If table contains a colon, use only the part before the colon
							if (table.includes(':')) {
								table = table.split(':')[0];
							}
							
							// Get options
							const options = this.getNodeParameter('options', i, {}) as IDataObject;
							const limit = options.limit as number;
							const start = options.start as number || 0;
							
							// Build the query with pagination, interpolating the table name directly
							// Table names usually cannot be parameterized in SQL-like languages
							let query = `SELECT * FROM ${table}`;
							
							// Only add LIMIT and START if explicitly provided
							const queryParams: Record<string, any> = {};
							
							if (limit !== undefined) {
								query += ` LIMIT $limit`;
								queryParams.limit = limit;
							}
							
							if (start > 0) {
								query += ` START $start`;
								queryParams.start = start;
							}
							
							// Prepare the query based on authentication type
							if (DEBUG) {
								// DEBUG: Log original query and credentials
								console.log('DEBUG - Original query:', query);
								console.log('DEBUG - Authentication type:', resolvedCredentials.authentication);
								console.log('DEBUG - Namespace:', resolvedCredentials.namespace);
								console.log('DEBUG - Database:', resolvedCredentials.database);
							}
							
							query = prepareSurrealQuery(query, resolvedCredentials);
							
							if (DEBUG) {
								// DEBUG: Log modified query
								console.log('DEBUG - Modified query:', query);
								console.log('DEBUG - Query params:', queryParams);
							}
							
							// Execute the query
							// Provide generic type argument for expected result structure: [any[]] - An array containing the array of records
							const result = await client.query<[any[]]>(query, queryParams);
							
							if (DEBUG) {
								// DEBUG: Log raw result
								console.log('DEBUG - Raw query result:', JSON.stringify(result));
								
								// The result from client.query is an array, where each element corresponds to a statement.
								// For queries with USE statements, the first element (result[0]) is null and the second element (result[1]) contains the records.
								console.log('DEBUG - Result structure:', JSON.stringify(result.map(r => typeof r)));
							}
							
							// Find the first non-null array in the result
							const recordsArray = Array.isArray(result) ? result.find(item => Array.isArray(item)) : null; // Find first array, even if empty
							
							if (recordsArray) { // Check if an array was found (could be empty)
								// Format the results
								const records = recordsArray;
								const formattedResults = formatArrayResult(records); // formatArrayResult([]) returns []
								
								// Add each record as a separate item
								for (const formattedResult of formattedResults) {
									returnData.push({
										...formattedResult,
										pairedItem: { item: i },
									});
								}
							}
							// If recordsArray is null (e.g., query error before finding an array), do nothing.
							// If recordsArray is [], formatArrayResult([]) returns [], loop doesn't run, returnData is unchanged.
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
				
				// Operation: Create Many
				else if (operation === 'createMany') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							// Get parameters
							let table = this.getNodeParameter('table', i) as string;
							if (DEBUG) console.log(`DEBUG (createMany) - Retrieved table parameter: ${table}`); // Log table

							// Ensure table is a string
							table = String(table || '');
							
							// If table contains a colon, use only the part before the colon
							if (table.includes(':')) {
								table = table.split(':')[0];
							}

							validateRequiredField(this, table, 'Table', i); // Validate table after potential extraction
							
							const dataInput = this.getNodeParameter('data', i); // Get the parameter named 'data' - could be string or array
							if (DEBUG) {
								console.log(`DEBUG (createMany) - Retrieved data parameter raw value:`, dataInput); // Log raw value
								console.log(`DEBUG (createMany) - Retrieved data parameter type: ${typeof dataInput}`); // Log type
							}
							
							// Validate required field based on raw input
							if (dataInput === undefined || dataInput === null || dataInput === '') {
								throw new Error('Records Data is required');
							}
							
							// Process data based on type
							let data: any;
							if (typeof dataInput === 'string') {
								// If it's a string, parse and validate as JSON
								if (DEBUG) console.log(`DEBUG (createMany) - Processing data parameter as string.`);
								data = validateJSON(this, dataInput, i);
							} else if (Array.isArray(dataInput)) {
								// If it's already an array, use it directly
								if (DEBUG) console.log(`DEBUG (createMany) - Processing data parameter as array.`);
								data = dataInput;
								// Optional: Add validation here to ensure it's an array of objects if needed
							} else {
								// Handle unexpected types
								throw new Error(`Records Data must be a JSON string or a JSON array, received type: ${typeof dataInput}`);
							}
							
							// Validate that data is an array after processing
							if (!Array.isArray(data)) {
								throw new Error('Processed Records Data must be an array');
							}
							if (DEBUG) console.log(`DEBUG (createMany) - Processed data (type: ${typeof data}):`, JSON.stringify(data)); // Log processed data
							
							// Execute the insert operation to create multiple records
							// The insert method accepts an array of objects directly
							const result = await client.insert(table, data);
							
							// The result from client.insert with an array is expected to be an array of created records.
							if (Array.isArray(result)) {
								// Format the results
								const formattedResults = formatArrayResult(result);
								
								// Add each record as a separate item
								for (const formattedResult of formattedResults) {
									returnData.push({
										...formattedResult,
										pairedItem: { item: i },
									});
								}
							} else {
								// If no records created, return an empty result
								returnData.push({
									json: { result: [] },
									pairedItem: { item: i },
								});
							}
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
				
				// Operation: Get Many
				else if (operation === 'getMany') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							// Get parameters
							let table = this.getNodeParameter('table', i) as string;
							const idsString = this.getNodeParameter('ids', i) as string;

							// Ensure table is a string
							table = String(table || '');
							
							// If table contains a colon, use only the part before the colon
							if (table.includes(':')) {
								table = table.split(':')[0];
							}

							// Ensure idsString is a string
							const idsStringStr = String(idsString || '');
							
							// If no table is specified but idsString has a table prefix, use the extracted table from the first ID
							if (!table && idsStringStr.includes(':')) {
								const firstId = idsString.split(',')[0]?.trim();
								if (firstId && firstId.includes(':')) {
									table = firstId.split(':')[0];
								}
							}

							// Only validate table as required if it couldn't be extracted from the Record IDs
							if (!table) {
								throw new Error('Either Table field must be provided or Record IDs must include a table prefix (e.g., "table:id")');
							}
							validateRequiredField(this, idsString, 'Record IDs', i);
							
							// Parse the comma-separated IDs
							const ids = idsString.split(',').map(id => id?.trim() || '').filter(id => id !== '');
							
							if (ids.length === 0) {
								// If no valid IDs provided after filtering, return no results for this item
								continue; 
							}
							
							// We need to use a query to select multiple records by ID
							// Build a list of full Record IDs for the IN clause, joined by comma ONLY
							const recordIdList = ids.map(id => {
								// Ensure id is a string before validation
								const idStr = String(id);
								// Validate each individual ID before adding to the list
								const validatedId = parseAndValidateRecordId(idStr, table, this.getNode(), i);
								return `${table}:${validatedId}`;
							}).join(',');
							
							// Build the query string with the Record IDs directly interpolated
							let query = `SELECT * FROM ${table} WHERE id IN [${recordIdList}]`;
							
							if (DEBUG) {
								// DEBUG: Log original query and credentials
								console.log('DEBUG - Get Many - Original query:', query);
								console.log('DEBUG - Get Many - Authentication type:', resolvedCredentials.authentication);
								console.log('DEBUG - Get Many - Namespace:', resolvedCredentials.namespace);
								console.log('DEBUG - Get Many - Database:', resolvedCredentials.database);
								console.log('DEBUG - Get Many - Record IDs:', recordIdList);
							}
							
							// Prepare the query based on authentication type
							query = prepareSurrealQuery(query, resolvedCredentials);
							
							if (DEBUG) {
								// DEBUG: Log modified query
								console.log('DEBUG - Get Many - Modified query:', query);
							}
							
							// Execute the query (no parameters needed for IDs now)
							const result = await client.query<[any[]]>(query);
							
							if (DEBUG) {
								// DEBUG: Log raw result
								console.log('DEBUG - Get Many - Raw query result:', JSON.stringify(result));
							}
							
							// Find the first non-null array in the result
							const recordsArray = Array.isArray(result) ? result.find(item => Array.isArray(item)) : null; // Find first array, even if empty
							
							if (recordsArray) { // Check if an array was found (could be empty)
								// Format the results
								const records = recordsArray;
								const formattedResults = formatArrayResult(records); // formatArrayResult([]) returns []
								
								// Add each record as a separate item
								for (const formattedResult of formattedResults) {
									returnData.push({
										...formattedResult,
										pairedItem: { item: i },
									});
								}
							}
							// If recordsArray is null or empty, do nothing, resulting in zero items for this input item
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
				
				// Operation: Update All Records
				else if (operation === 'updateAllRecords') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							// Get parameters
							let table = this.getNodeParameter('table', i) as string;
							validateRequiredField(this, table, 'Table', i);

							// Ensure table is a string
							table = String(table || '');
							
							// If table contains a colon, use only the part before the colon
							if (table.includes(':')) {
								table = table.split(':')[0];
							}
							
							const dataInput = this.getNodeParameter('data', i); // Get potential object or string
							// Validate required field based on raw input
							if (dataInput === undefined || dataInput === null || dataInput === '') {
								throw new Error('Update Data is required');
							}
							
							// Process data based on type
							let data: any;
							if (typeof dataInput === 'string') {
								if (DEBUG) console.log(`DEBUG (updateAllRecords) - Processing data parameter as string.`);
								data = validateJSON(this, dataInput, i);
							} else if (typeof dataInput === 'object' && dataInput !== null) { // Check if it's a non-null object
								if (DEBUG) console.log(`DEBUG (updateAllRecords) - Processing data parameter as object.`);
								data = dataInput;
							} else {
								throw new Error(`Update Data must be a JSON string or a JSON object, received type: ${typeof dataInput}`);
							}
							if (DEBUG) console.log(`DEBUG (updateAllRecords) - Processed data (type: ${typeof data}):`, JSON.stringify(data));
							
							// Build the update query
							// We use UPDATE with no WHERE clause to update all records in the table
							let query = `UPDATE ${table} CONTENT $data`;
							
							if (DEBUG) {
								// DEBUG: Log original query and credentials
								console.log('DEBUG - Update All Records - Original query:', query);
								console.log('DEBUG - Update All Records - Authentication type:', resolvedCredentials.authentication);
								console.log('DEBUG - Update All Records - Namespace:', resolvedCredentials.namespace);
								console.log('DEBUG - Update All Records - Database:', resolvedCredentials.database);
								console.log('DEBUG - Update All Records - Data:', JSON.stringify(data));
							}
							
							// Prepare the query based on authentication type
							query = prepareSurrealQuery(query, resolvedCredentials);
							
							if (DEBUG) {
								// DEBUG: Log modified query
								console.log('DEBUG - Update All Records - Modified query:', query);
							}
							
							// Execute the query with the data parameter
							const result = await client.query<[any[]]>(query, { data });
							
							if (DEBUG) {
								// DEBUG: Log raw result
								console.log('DEBUG - Update All Records - Raw query result:', JSON.stringify(result));
							}
							
							// Find the first non-null array in the result
							const recordsArray = Array.isArray(result) ? result.find(item => Array.isArray(item)) : null; // Find first array, even if empty
							
							if (recordsArray) { // Check if an array was found (could be empty)
								// Format the results
								const records = recordsArray;
								const formattedResults = formatArrayResult(records); // formatArrayResult([]) returns []
								
								// Add each record as a separate item
								for (const formattedResult of formattedResults) {
									returnData.push({
										...formattedResult,
										pairedItem: { item: i },
									});
								}
							} else {
								// If no records were updated or the result is not as expected, return a status message
								returnData.push({
									json: { 
										result: 'Update operation completed',
										table,
										data
									},
									pairedItem: { item: i },
								});
							}
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
				
				// Operation: Delete All Records
				else if (operation === 'deleteAllRecords') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							// Get parameters
							let table = this.getNodeParameter('table', i) as string;
							validateRequiredField(this, table, 'Table', i);

							// Ensure table is a string
							table = String(table || '');
							
							// If table contains a colon, use only the part before the colon
							if (table.includes(':')) {
								table = table.split(':')[0];
							}
							
							// Build the delete query
							// We use DELETE with no WHERE clause to delete all records in the table
							let query = `DELETE FROM ${table}`;
							
							if (DEBUG) {
								// DEBUG: Log original query and credentials
								console.log('DEBUG - Delete All Records - Original query:', query);
								console.log('DEBUG - Delete All Records - Authentication type:', resolvedCredentials.authentication);
								console.log('DEBUG - Delete All Records - Namespace:', resolvedCredentials.namespace);
								console.log('DEBUG - Delete All Records - Database:', resolvedCredentials.database);
							}
							
							// Prepare the query based on authentication type
							query = prepareSurrealQuery(query, resolvedCredentials);
							
							if (DEBUG) {
								// DEBUG: Log modified query
								console.log('DEBUG - Delete All Records - Modified query:', query);
							}
							
							// Execute the query
							const result = await client.query<[any[]]>(query);
							
							if (DEBUG) {
								// DEBUG: Log raw result
								console.log('DEBUG - Delete All Records - Raw query result:', JSON.stringify(result));
							}
							
							// Find the first non-null array in the result
							const recordsArray = Array.isArray(result) ? result.find(item => Array.isArray(item)) : null; // Find first array, even if empty
							
							if (recordsArray) { // Check if an array was found (could be empty)
								// Format the results
								const records = recordsArray;
								const formattedResults = formatArrayResult(records); // formatArrayResult([]) returns []
								
								// Add each record as a separate item
								for (const formattedResult of formattedResults) {
									returnData.push({
										...formattedResult,
										pairedItem: { item: i },
									});
								}
							} else {
								// If no records were deleted or the result is not as expected, return a status message
								returnData.push({
									json: { 
										result: 'Delete operation completed',
										table
									},
									pairedItem: { item: i },
								});
							}
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
				
				// Operation: Merge All Records
				else if (operation === 'mergeAllRecords') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							// Get parameters
							let table = this.getNodeParameter('table', i) as string;
							validateRequiredField(this, table, 'Table', i);

							// Ensure table is a string
							table = String(table || '');
							
							// If table contains a colon, use only the part before the colon
							if (table.includes(':')) {
								table = table.split(':')[0];
							}
							
							const dataInput = this.getNodeParameter('data', i); // Get potential object or string
							// Validate required field based on raw input
							if (dataInput === undefined || dataInput === null || dataInput === '') {
								throw new Error('Merge Data is required');
							}
							
							// Process data based on type
							let data: any;
							if (typeof dataInput === 'string') {
								if (DEBUG) console.log(`DEBUG (mergeAllRecords) - Processing data parameter as string.`);
								data = validateJSON(this, dataInput, i);
							} else if (typeof dataInput === 'object' && dataInput !== null) { // Check if it's a non-null object
								if (DEBUG) console.log(`DEBUG (mergeAllRecords) - Processing data parameter as object.`);
								data = dataInput;
							} else {
								throw new Error(`Merge Data must be a JSON string or a JSON object, received type: ${typeof dataInput}`);
							}
							if (DEBUG) console.log(`DEBUG (mergeAllRecords) - Processed data (type: ${typeof data}):`, JSON.stringify(data));
							
							// Build the merge query
							// We use UPDATE with no WHERE clause and MERGE to merge data into all records in the table
							let query = `UPDATE ${table} MERGE $data`;
							
							if (DEBUG) {
								// DEBUG: Log original query and credentials
								console.log('DEBUG - Merge All Records - Original query:', query);
								console.log('DEBUG - Merge All Records - Authentication type:', resolvedCredentials.authentication);
								console.log('DEBUG - Merge All Records - Namespace:', resolvedCredentials.namespace);
								console.log('DEBUG - Merge All Records - Database:', resolvedCredentials.database);
								console.log('DEBUG - Merge All Records - Data:', JSON.stringify(data));
							}
							
							// Prepare the query based on authentication type
							query = prepareSurrealQuery(query, resolvedCredentials);
							
							if (DEBUG) {
								// DEBUG: Log modified query
								console.log('DEBUG - Merge All Records - Modified query:', query);
							}
							
							// Execute the query with the data parameter
							const result = await client.query<[any[]]>(query, { data });
							
							if (DEBUG) {
								// DEBUG: Log raw result
								console.log('DEBUG - Merge All Records - Raw query result:', JSON.stringify(result));
							}
							
							// Find the first non-null array in the result
							const recordsArray = Array.isArray(result) ? result.find(item => Array.isArray(item)) : null; // Find first array, even if empty
							
							if (recordsArray) { // Check if an array was found (could be empty)
								// Format the results
								const records = recordsArray;
								const formattedResults = formatArrayResult(records); // formatArrayResult([]) returns []
								
								// Add each record as a separate item
								for (const formattedResult of formattedResults) {
									returnData.push({
										...formattedResult,
										pairedItem: { item: i },
									});
								}
							} else {
								// If no records were merged or the result is not as expected, return a status message
								returnData.push({
									json: { 
										result: 'Merge operation completed',
										table,
										data
									},
									pairedItem: { item: i },
								});
							}
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
			}
			
			// ----------------------------------------
			// Resource: Query
			// ----------------------------------------
			else if (resource === 'query') {
				
				// Operation: Execute Query
				if (operation === 'executeQuery') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							// Get parameters
							const query = this.getNodeParameter('query', i) as string;
							validateRequiredField(this, query, 'Query', i);
							
							// Get parameters if provided
							const parametersInput = this.getNodeParameter('parameters', i, {}); // Default to empty object if not provided
							
							// Process parameters based on type
							let parameters: any;
							if (typeof parametersInput === 'string') {
								// If it's a string, parse and validate as JSON
								if (DEBUG) console.log(`DEBUG (executeQuery) - Processing parameters parameter as string.`);
								parameters = validateJSON(this, parametersInput, i);
							} else if (typeof parametersInput === 'object' && parametersInput !== null) { // Check if it's a non-null object
								if (DEBUG) console.log(`DEBUG (executeQuery) - Processing parameters parameter as object.`);
								parameters = parametersInput;
							} else {
								throw new Error(`Parameters must be a JSON string or a JSON object, received type: ${typeof parametersInput}`);
							}
							if (DEBUG) console.log(`DEBUG (executeQuery) - Processed parameters (type: ${typeof parameters}):`, JSON.stringify(parameters));
							
							// Get options
							const options = this.getNodeParameter('options', i, {}) as IDataObject;
							const limit = options.limit as number;
							const start = options.start as number;
							
							// Check if the query already contains LIMIT or START clauses
							const hasLimit = query.toUpperCase().includes('LIMIT');
							const hasStart = query.toUpperCase().includes('START');
							
							// Modify the query to add pagination if needed
							let finalQuery = query;
							if (limit !== undefined && !hasLimit) {
								finalQuery += ` LIMIT ${limit}`;
							}
							if (start !== undefined && !hasStart) {
								finalQuery += ` START ${start}`;
							}
							
							// Prepare the query based on authentication type
							finalQuery = prepareSurrealQuery(finalQuery, resolvedCredentials);
							
							// Execute the query
							const result = await client.query(finalQuery, parameters);
							
							if (DEBUG) {
								// DEBUG: Log raw result
								console.log('DEBUG - Execute Query - Raw query result:', JSON.stringify(result));
								console.log('DEBUG - Execute Query - Result structure:', JSON.stringify(result.map(r => typeof r)));
							}
							
							// The result is an array of arrays, where each array contains the results of a statement
							if (Array.isArray(result)) {
								// Process each result set, filtering out null values
								for (const resultSet of result.filter(item => item !== null)) {
									if (Array.isArray(resultSet)) {
										// For array results, return each item as a separate n8n item
										const formattedResults = formatArrayResult(resultSet);
										for (const formattedResult of formattedResults) {
											returnData.push({
												...formattedResult,
												pairedItem: { item: i },
											});
										}
									} else {
										// For single results, use the formatSingleResult function
										const formattedResult = formatSingleResult(resultSet);
										returnData.push({
											...formattedResult,
											pairedItem: { item: i },
										});
									}
								}
							} else {
								// If the result is not an array, format it as a single result
								const formattedResult = formatSingleResult(result);
								returnData.push({
									...formattedResult,
									pairedItem: { item: i },
								});
							}
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
			}
			
			// ----------------------------------------
			// Resource: System
			// ----------------------------------------
			else if (resource === 'system') {
				
				// Operation: Health Check
				if (operation === 'healthCheck') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							// Get the base URL from the connection string
							// Remove /rpc if it exists
							let baseUrl = resolvedCredentials.connectionString;
							if (baseUrl.endsWith('/rpc')) {
								baseUrl = baseUrl.slice(0, -4);
							}
							
							// Ensure the URL ends with a slash
							if (!baseUrl.endsWith('/')) {
								baseUrl += '/';
							}
							
							// Create the health check URL
							const healthUrl = `${baseUrl}health`;
							
							// Use n8n's httpRequest helper to perform a GET request
							const options: IHttpRequestOptions = {
								url: healthUrl,
								method: 'GET',
								returnFullResponse: true,
							};
							
							try {
								// Perform the health check request
								const response = await this.helpers.httpRequest(options);
								
								// Format the result
								returnData.push({
									json: {
										status: 'healthy',
										details: response,
									},
									pairedItem: { item: i },
								});
							} catch (error) {
								// Do not throw an error on failure, just return unhealthy status
								returnData.push({
									json: {
										status: 'unhealthy',
										details: (error as Error).message,
									},
									pairedItem: { item: i },
								});
							}
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
				
				// Operation: Version
				else if (operation === 'version') {
					for (let i = 0; i < itemsLength; i++) {
						try {
							let version = 'unknown';
							let details = '';
							
							// First, attempt to get version using INFO FOR SERVER query
							try {
								// Prepare the query based on authentication type
								const infoQuery = prepareSurrealQuery('INFO FOR SERVER', resolvedCredentials);
								const result = await client.query(infoQuery);
								
								// Parse the version from the result
								if (Array.isArray(result) && result.length > 0 && result[0]) {
									const serverInfo = result[0];
									if (typeof serverInfo === 'object' && serverInfo !== null) {
										// Extract version from the server info
										// The exact structure depends on SurrealDB's response format
										// This might need adjustment based on actual response
										version = (serverInfo as any).version || 'unknown';
									}
								}
							} catch (queryError) {
								// If the query fails, use the /version endpoint as a fallback
								try {
									// Get the base URL from the connection string
									// Remove /rpc if it exists
									let baseUrl = resolvedCredentials.connectionString;
									if (baseUrl.endsWith('/rpc')) {
										baseUrl = baseUrl.slice(0, -4);
									}
									
									// Ensure the URL ends with a slash
									if (!baseUrl.endsWith('/')) {
										baseUrl += '/';
									}
									
									// Create the version URL
									const versionUrl = `${baseUrl}version`;
									
									// Use n8n's httpRequest helper to perform a GET request
									const options: IHttpRequestOptions = {
										url: versionUrl,
										method: 'GET',
									};
									
									// Perform the version request
									const response = await this.helpers.httpRequest(options);
									
									// Extract version from response
									if (response && typeof response === 'string') {
										version = response.trim();
									} else if (response && typeof response === 'object') {
										version = (response as any).version || 'unknown';
									}
								} catch (httpError) {
									// If both methods fail, set details to the error message
									details = `Failed to retrieve version: ${(queryError as Error).message}, ${(httpError as Error).message}`;
								}
							}
							
							// Format the result
							returnData.push({
								json: {
									version,
									details,
								},
								pairedItem: { item: i },
							});
						} catch (error) {
							if (this.continueOnFail()) {
								returnData.push({
									json: { error: (error as JsonObject).message },
									pairedItem: { item: i },
								});
								continue;
							}
							throw error;
						}
					}
				}
			}
		} finally {
			// Always close the connection
			await client.close();
		}

		return [returnData];
	}
}
